<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>Luxury Christmas Tree</title>
    <style>
        body, html { 
            margin: 0; padding: 0; width: 100%; height: 100%; 
            overflow: hidden; background-color: #010201; 
            font-family: -apple-system, "Microsoft YaHei", sans-serif;
            touch-action: none; /* å…³é”®ï¼šé˜²æ­¢æ‰‹æœºç«¯ä¸‹æ‹‰åˆ·æ–°æ‰“æ–­ä½“éªŒ */
        }
        
        #canvas-container { position: fixed; top: 0; left: 0; right: 0; bottom: 0; z-index: 2; }
        
        /* è§†é¢‘å±‚ (ARæ¨¡å¼èƒŒæ™¯) */
        #video-container {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            z-index: 0; display: none; background: #000;
        }
        
        #webcam { 
            width: 100%; height: 100%; object-fit: cover; 
            transform: scaleX(-1); display: block;
        }

        /* æŒ‰é’®æ ·å¼é€‚é… PC å’Œ æ‰‹æœº */
        .ui-btn {
            position: absolute; bottom: 40px; 
            padding: 12px 24px;
            background: rgba(255, 255, 255, 0.1); 
            border: 1px solid rgba(255, 215, 0, 0.4);
            color: #ffd700; border-radius: 30px; 
            backdrop-filter: blur(10px); -webkit-backdrop-filter: blur(10px);
            font-size: 14px; font-weight: bold; cursor: pointer;
            z-index: 20; transition: all 0.3s;
            user-select: none;
        }
        .ui-btn:hover { background: rgba(255, 215, 0, 0.2); box-shadow: 0 0 15px rgba(255, 215, 0, 0.3); }
        .ui-btn:active { transform: scale(0.95); }
        .ui-btn.disabled { opacity: 0.5; cursor: not-allowed; background: #333; border-color: #555; color: #888; }

        #btn-ar { left: 50%; transform: translateX(-140%); }
        #btn-photo { right: 50%; transform: translateX(140%); }
        
        /* æ‰‹æœºç«¯å¸ƒå±€è°ƒæ•´ */
        @media (max-width: 600px) {
            #btn-ar { left: 20px; transform: none; }
            #btn-photo { right: 20px; transform: none; }
        }

        #file-input { display: none; }

        /* åŠ è½½é¡µæ ·å¼ä¼˜åŒ– */
        #loader {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: #020502; z-index: 999;
            display: flex; flex-direction: column; 
            align-items: center; justify-content: center;
            color: #d4af37; transition: opacity 0.5s;
        }
        .loader-text { font-size: 16px; margin-bottom: 10px; letter-spacing: 2px; }
        .loader-sub { font-size: 12px; color: #666; }
        .error-msg { color: #ff4444; margin-top: 20px; font-size: 12px; max-width: 80%; text-align: center; }

        #tips {
            position: fixed; top: 15%; width: 100%; text-align: center;
            color: rgba(255, 255, 255, 0.7); font-size: 14px; z-index: 10;
            pointer-events: none; text-shadow: 0 2px 4px rgba(0,0,0,0.8);
            opacity: 0; transition: opacity 0.5s;
        }
    </style>
    
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/",
                "@mediapipe/tasks-vision": "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3/+esm"
            }
        }
    </script>
    
    <script>
        window.addEventListener('error', function(e) {
            const loader = document.getElementById('loader');
            const errorDiv = document.getElementById('error-log');
            if(loader && loader.style.display !== 'none') {
                errorDiv.innerHTML += `åŠ è½½é”™è¯¯: ${e.message}<br>`;
            }
        });
    </script>
</head>
<body>

    <div id="loader">
        <div class="loader-text">æ­£åœ¨å¯åŠ¨å¼•æ“...</div>
        <div class="loader-sub">é¦–æ¬¡åŠ è½½å¯èƒ½éœ€è¦ 10-20 ç§’</div>
        <div id="error-log" class="error-msg"></div>
    </div>
    
    <div id="tips">ğŸ’» é¼ æ ‡æ‚¬åœ / ğŸ“± é•¿æŒ‰ ç…§ç‰‡å¯æ”¾å¤§</div>
    
    <div id="canvas-container"></div>
    
    <div id="video-container">
        <video id="webcam" autoplay muted playsinline webkit-playsinline></video>
    </div>

    <button id="btn-ar" class="ui-btn disabled">â³ AIç»„ä»¶åŠ è½½ä¸­...</button>
    <button id="btn-photo" class="ui-btn">ğŸ“· æ¢ç…§ç‰‡</button>
    <input type="file" id="file-input" multiple accept="image/*">

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { FilesetResolver, HandLandmarker } from '@mediapipe/tasks-vision';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
        import { RGBELoader } from 'three/addons/loaders/RGBELoader.js';

        // --- é…ç½® ---
        const CONFIG = {
            particleCount: 15000,
            particleSize: 0.08,
            mode: '3D',
            bloomThreshold: 0.6,
            bloomStrength: 1.0,
            bloomRadius: 0.5,
            photoCount: 36
        };

        // --- å˜é‡ ---
        let scene, camera, renderer, particles, geometry, material;
        let controls, composer, bloomPass;
        let luxuryGroup, foliageSystem, spiralMesh, spiralMaterial, starMesh, starMaterial, starLight;
        let photoGroup, raycaster, mouse = new THREE.Vector2();
        
        let instancedGifts, instancedBalls, instancedLights;
        const treeOrnaments = [];
        const photoObjects = [];
        let activePhoto = null;
        let hoverStartTime = 0;
        let hoveredObject = null;

        let handLandmarker = undefined;
        let webcamRunning = false;
        let lastVideoTime = -1;
        const video = document.getElementById('webcam');
        const videoContainer = document.getElementById('video-container');

        const defaultImages = [
            'https://images.unsplash.com/photo-1514888286974-6c03e2ca1dba?w=400&q=80', 
            'https://images.unsplash.com/photo-1543466835-00a7907e9de1?w=400&q=80', 
            'https://images.unsplash.com/photo-1537151608828-ea2b11777ee8?w=400&q=80'
        ];

        // è¶…æ—¶ä¿æŠ¤ï¼š5ç§’åæ— è®ºå¦‚ä½•è¿›å…¥åœºæ™¯ï¼ˆé˜²æ­¢AIåŠ è½½å¡æ­»ï¼‰
        setTimeout(() => {
            const loader = document.getElementById('loader');
            if (loader && loader.style.opacity !== '0') {
                console.log("Loading timeout, forcing entry...");
                loader.style.opacity = '0';
                setTimeout(() => { loader.style.display = 'none'; }, 500);
            }
        }, 8000);

        init();

        function init() {
            try {
                const container = document.getElementById('canvas-container');

                scene = new THREE.Scene();
                scene.background = new THREE.Color(0x010201);

                // è°ƒæ•´æ‘„åƒæœºï¼šPCç«¯è§†é‡ç¨å¾®å¹¿ä¸€ç‚¹
                camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
                camera.position.set(0, 3, 30);

                renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
                renderer.setSize(window.innerWidth, window.innerHeight);
                // æ™ºèƒ½è®¾ç½®åƒç´ æ¯”ï¼šç”µè„‘ç”¨1ï¼Œæ‰‹æœºæœ€é«˜ç”¨2ï¼ˆé˜²æ­¢å‘çƒ­ï¼‰
                renderer.setPixelRatio(Math.min(window.devicePixelRatio, (window.innerWidth < 600 ? 2 : 1)));
                renderer.toneMapping = THREE.ACESFilmicToneMapping;
                renderer.toneMappingExposure = 0.8;
                container.appendChild(renderer.domElement);

                // åæœŸå¤„ç†
                const renderScene = new RenderPass(scene, camera);
                bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
                bloomPass.threshold = CONFIG.bloomThreshold;
                bloomPass.strength = CONFIG.bloomStrength;
                bloomPass.radius = CONFIG.bloomRadius;

                composer = new EffectComposer(renderer);
                composer.addPass(renderScene);
                composer.addPass(bloomPass);

                // HDRI ç¯å¢ƒå…‰
                new RGBELoader()
                    .setPath('https://raw.githubusercontent.com/mrdoob/three.js/master/examples/textures/equirectangular/')
                    .load('royal_esplanade_1k.hdr', function (texture) {
                        texture.mapping = THREE.EquirectangularReflectionMapping;
                        scene.environment = texture;
                    });

                // æ§åˆ¶å™¨ï¼šå…¼å®¹é¼ æ ‡å’Œè§¦æ‘¸
                controls = new OrbitControls(camera, renderer.domElement);
                controls.enableDamping = true;
                controls.dampingFactor = 0.05;
                controls.autoRotate = true;
                controls.autoRotateSpeed = 0.5;
                controls.enableZoom = true;
                controls.minDistance = 5;
                controls.maxDistance = 100;

                createParticles();
                createLuxuryTree();
                createPhotoCloud();
                updateShape('åœ£è¯æ ‘');
                
                window.addEventListener('resize', onWindowResize);
                
                // äº¤äº’äº‹ä»¶ç›‘å¬
                window.addEventListener('mousemove', onMouseMove);
                window.addEventListener('touchmove', onTouchMove, { passive: false });
                window.addEventListener('touchstart', onTouchStart, { passive: false });
                
                // æŒ‰é’®ç»‘å®š
                document.getElementById('btn-ar').addEventListener('click', toggleARMode);
                const uploadBtn = document.getElementById('btn-photo');
                const fileInput = document.getElementById('file-input');
                uploadBtn.addEventListener('click', () => fileInput.click());
                fileInput.addEventListener('change', handlePhotoUpload);

                // ç«‹å³éšè—åŠ è½½å±‚ï¼ˆä¸ç­‰å¾…AIï¼‰
                const loader = document.getElementById('loader');
                loader.style.opacity = '0';
                setTimeout(() => { loader.style.display = 'none'; showTip(); }, 500);

                animate();

                // å¼‚æ­¥åŠ è½½AI
                loadAIModel();

            } catch (e) {
                document.getElementById('error-log').innerText = "åˆå§‹åŒ–å´©æºƒ: " + e.message;
            }
        }

        async function loadAIModel() {
            try {
                // å°è¯•åŠ è½½ AI
                const vision = await FilesetResolver.forVisionTasks("https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3/wasm");
                handLandmarker = await HandLandmarker.createFromOptions(vision, {
                    baseOptions: {
                        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/hand_landmarker/hand_landmarker/float16/1/hand_landmarker.task`,
                        delegate: "GPU"
                    },
                    runningMode: "VIDEO",
                    numHands: 1
                });
                
                const btnAr = document.getElementById('btn-ar');
                btnAr.innerText = "ğŸ”´ å¼€å¯ AR / æ‘„åƒå¤´";
                btnAr.classList.remove('disabled');
                
            } catch (err) {
                console.warn("AI Load Failed:", err);
                const btnAr = document.getElementById('btn-ar');
                // å³ä½¿AIå¤±è´¥ï¼Œä¹Ÿå¯ä»¥å°è¯•å¼€å¯æ‘„åƒå¤´åšçº¯èƒŒæ™¯
                btnAr.innerText = "âš ï¸ ä»…å¼€å¯æ‘„åƒå¤´ (æ— æ‰‹åŠ¿)";
                btnAr.classList.remove('disabled');
                // æ ‡è®°ä¸€ä¸ªçŠ¶æ€ï¼Œå…è®¸æ— AIå¼€å¯
                CONFIG.noAI = true;
            }
        }

        function toggleARMode() {
            const btn = document.getElementById('btn-ar');
            if (btn.classList.contains('disabled')) return;

            if (CONFIG.mode === '3D') {
                // æ£€æŸ¥HTTPS (æœ¬åœ°è°ƒè¯•é™¤å¤–)
                if (location.protocol !== 'https:' && location.hostname !== 'localhost' && location.hostname !== '127.0.0.1') {
                    alert("å®‰å…¨é™åˆ¶ï¼šæ‘„åƒå¤´éœ€è¦ HTTPS è¿æ¥ã€‚\nè¯·ä½¿ç”¨ GitHub Pages ç”Ÿæˆçš„ https é“¾æ¥è®¿é—®ã€‚");
                    return;
                }

                CONFIG.mode = 'AR';
                webcamRunning = true;
                videoContainer.style.display = 'block';
                scene.background = null; // é€æ˜èƒŒæ™¯
                controls.autoRotate = false; // ARæ¨¡å¼åœæ­¢æ—‹è½¬
                
                btn.innerText = "ğŸ”´ å…³é—­æ‘„åƒå¤´";
                btn.style.background = "rgba(255, 50, 50, 0.4)";

                const constraints = { video: { facingMode: 'user', width: { ideal: 1280 }, height: { ideal: 720 } } };
                
                navigator.mediaDevices.getUserMedia(constraints).then((stream) => {
                    video.srcObject = stream;
                    video.play();
                    if (!CONFIG.noAI) {
                        video.addEventListener("loadeddata", predictWebcam);
                    }
                }).catch(err => {
                    alert("æ— æ³•è®¿é—®æ‘„åƒå¤´: " + err.message + "\n(ç”µè„‘è¯·æ£€æŸ¥æµè§ˆå™¨æƒé™ï¼Œæ‰‹æœºè¯·æ£€æŸ¥å¾®ä¿¡æƒé™)");
                    toggleARMode(); // å›é€€
                });

            } else {
                CONFIG.mode = '3D';
                webcamRunning = false;
                videoContainer.style.display = 'none';
                scene.background = new THREE.Color(0x010201);
                controls.autoRotate = true;
                
                btn.innerText = CONFIG.noAI ? "âš ï¸ ä»…å¼€å¯æ‘„åƒå¤´ (æ— æ‰‹åŠ¿)" : "ğŸ”´ å¼€å¯ AR / æ‘„åƒå¤´";
                btn.style.background = "rgba(255, 255, 255, 0.1)";
                
                const stream = video.srcObject;
                if(stream) stream.getTracks().forEach(track => track.stop());
                video.srcObject = null;
            }
        }

        async function predictWebcam() {
            if (lastVideoTime !== video.currentTime && CONFIG.mode === 'AR') {
                lastVideoTime = video.currentTime;
                const startTimeMs = performance.now();
                if (handLandmarker) {
                    const result = handLandmarker.detectForVideo(video, startTimeMs);
                    if (result.landmarks.length > 0) {
                        const landmarks = result.landmarks[0];
                        const thumb = landmarks[4];
                        const index = landmarks[8];
                        const dist = Math.sqrt(Math.pow(thumb.x - index.x, 2) + Math.pow(thumb.y - index.y, 2));
                        let val = (dist - 0.05) * 5; 
                        val = Math.max(0, Math.min(1, val));
                        CONFIG.expansion += (val - CONFIG.expansion) * 0.1;
                    } else {
                         CONFIG.expansion += (0 - CONFIG.expansion) * 0.05;
                    }
                }
            }
            if (webcamRunning && !CONFIG.noAI) window.requestAnimationFrame(predictWebcam);
        }

        // --- åœºæ™¯æ„å»º ---
        function createLuxuryTree() {
            luxuryGroup = new THREE.Group();
            luxuryGroup.visible = false;
            scene.add(luxuryGroup);

            // 1. é’ˆå¶
            const foliageCount = 20000; 
            const foliageGeo = new THREE.BufferGeometry();
            const foliagePos = new Float32Array(foliageCount * 3);
            const foliageColors = new Float32Array(foliageCount * 3);
            const baseColor = new THREE.Color(0x00260e); const tipColor = new THREE.Color(0x006633); 
            for (let i = 0; i < foliageCount; i++) {
                const h = Math.random(); const angle = Math.random() * Math.PI * 2; 
                const r = (1 - h) * 9 * Math.sqrt(Math.random()); 
                const x = Math.cos(angle) * r; const y = h * 22 - 11; const z = Math.sin(angle) * r;
                foliagePos[i*3] = x; foliagePos[i*3+1] = y; foliagePos[i*3+2] = z;
                const mixedColor = baseColor.clone().lerp(tipColor, Math.random() * 0.6);
                foliageColors[i*3] = mixedColor.r; foliageColors[i*3+1] = mixedColor.g; foliageColors[i*3+2] = mixedColor.b;
            }
            foliageGeo.setAttribute('position', new THREE.BufferAttribute(foliagePos, 3));
            foliageGeo.setAttribute('color', new THREE.BufferAttribute(foliageColors, 3));
            const foliageMat = new THREE.ShaderMaterial({
                uniforms: { time: { value: 0 }, pointSize: { value: 4.0 } }, 
                vertexShader: `uniform float time; uniform float pointSize; attribute vec3 color; varying vec3 vColor; void main() { vColor = color; vec3 pos = position; pos.x += sin(time * 0.5 + pos.y) * 0.05; vec4 mvPosition = modelViewMatrix * vec4(pos, 1.0); gl_PointSize = pointSize * (30.0 / -mvPosition.z); gl_Position = projectionMatrix * mvPosition; }`,
                fragmentShader: `varying vec3 vColor; void main() { if (length(gl_PointCoord - vec2(0.5)) > 0.5) discard; gl_FragColor = vec4(vColor, 1.0); }`,
                transparent: true, depthWrite: false, blending: THREE.NormalBlending 
            });
            foliageSystem = new THREE.Points(foliageGeo, foliageMat);
            foliageSystem.frustumCulled = false; 
            luxuryGroup.add(foliageSystem);

            // 2. è£…é¥°ç‰©
            const setupInstancedMesh = (geo, mat, count, weightType) => {
                const mesh = new THREE.InstancedMesh(geo, mat, count);
                const dummy = new THREE.Object3D();
                for(let i=0; i<count; i++) {
                    const h = Math.random(); const angle = Math.random() * Math.PI * 2; const r = ((1 - h) * 9) + 0.3; 
                    const x = Math.cos(angle) * r; const y = h * 22 - 11; const z = Math.sin(angle) * r;
                    dummy.position.set(x, y, z);
                    const s = Math.random() * 0.5 + 0.5;
                    dummy.scale.set(s, s, s); dummy.rotation.set(Math.random()*Math.PI, Math.random()*Math.PI, 0); dummy.updateMatrix();
                    mesh.setMatrixAt(i, dummy.matrix);
                    treeOrnaments.push({ mesh: mesh, index: i, basePos: new THREE.Vector3(x, y, z), baseScale: s, weightType: weightType, phase: Math.random() * Math.PI * 2, currentPos: new THREE.Vector3(x, y, z) });
                }
                mesh.instanceMatrix.needsUpdate = true; mesh.frustumCulled = false; luxuryGroup.add(mesh);
                return mesh;
            };
            const boxGeo = new THREE.BoxGeometry(0.6, 0.6, 0.6);
            const boxMat = new THREE.MeshStandardMaterial({ color: 0x550000, roughness: 0.3, metalness: 0.7, envMapIntensity: 2.0 }); 
            instancedGifts = setupInstancedMesh(boxGeo, boxMat, 80, 2);
            const ballGeo = new THREE.SphereGeometry(0.35, 16, 16);
            const ballMat = new THREE.MeshStandardMaterial({ color: 0xDDAA00, roughness: 0.1, metalness: 0.9, envMapIntensity: 2.5 }); 
            instancedBalls = setupInstancedMesh(ballGeo, ballMat, 300, 1);
            const lightGeo = new THREE.SphereGeometry(0.12, 8, 8);
            const lightMat = new THREE.MeshBasicMaterial({ color: 0xffaa55 }); 
            instancedLights = setupInstancedMesh(lightGeo, lightMat, 600, 0);

            // 3. èºæ—‹å‘¼å¸ç¯ç  (ä¼˜åŒ–)
            const beadCount = 1200; 
            const spiralTurns = 6.5; const spiralHeight = 23; const spiralBaseRadius = 10.5;
            const beadGeo = new THREE.SphereGeometry(0.075, 6, 6); 
            spiralMaterial = new THREE.MeshBasicMaterial({ color: 0xcc8800 }); 
            spiralMesh = new THREE.InstancedMesh(beadGeo, spiralMaterial, beadCount);
            const dummyBead = new THREE.Object3D();
            for(let i = 0; i < beadCount; i++) {
                const ratio = i / beadCount; const angle = ratio * Math.PI * 2 * spiralTurns;
                const y = (ratio * spiralHeight) - 11.5; const r = (1 - ratio * 0.9) * spiralBaseRadius; 
                const x = Math.cos(angle) * r; const z = Math.sin(angle) * r;
                dummyBead.position.set(x, y, z); dummyBead.updateMatrix(); spiralMesh.setMatrixAt(i, dummyBead.matrix);
                treeOrnaments.push({ mesh: spiralMesh, index: i, basePos: new THREE.Vector3(x, y, z), baseScale: 1.0, weightType: 0, phase: angle, currentPos: new THREE.Vector3(x, y, z) });
            }
            spiralMesh.instanceMatrix.needsUpdate = true; spiralMesh.frustumCulled = false; luxuryGroup.add(spiralMesh);

            // 4. æ°´æ™¶é¡¶æ˜Ÿ
            const starShape = new THREE.Shape();
            const outerRadius = 1.5; const innerRadius = 0.6; const starPoints = 5;
            for (let i = 0; i < starPoints * 2; i++) {
                const angle = (i * Math.PI) / starPoints; const radius = i % 2 === 0 ? outerRadius : innerRadius;
                const x = Math.cos(angle) * radius; const y = Math.sin(angle) * radius;
                if(i===0) starShape.moveTo(x, y); else starShape.lineTo(x, y);
            }
            starShape.closePath();
            const starGeo = new THREE.ExtrudeGeometry(starShape, { depth: 0.5, bevelEnabled: true, bevelThickness: 0.2, bevelSize: 0.15, bevelSegments: 2 });
            starGeo.center(); 
            starMaterial = new THREE.MeshPhysicalMaterial({
                color: 0xffffff, metalness: 0.1, roughness: 0.02, transmission: 1.0, ior: 2.3, thickness: 1.5,
                envMapIntensity: 5.0, clearcoat: 1.0, side: THREE.DoubleSide, emissive: 0x333333, emissiveIntensity: 0.2 
            });
            starMesh = new THREE.Mesh(starGeo, starMaterial); starMesh.position.set(0, 12, 0); luxuryGroup.add(starMesh);
            starLight = new THREE.PointLight(0xffffff, 0.6, 25); starLight.position.set(0, 12, 0); luxuryGroup.add(starLight);
        }

        function createPhotoCloud() {
            photoGroup = new THREE.Group();
            luxuryGroup.add(photoGroup);
            const loader = new THREE.TextureLoader();
            const frameGeo = new THREE.PlaneGeometry(0.8, 1.0); 
            const borderGeo = new THREE.PlaneGeometry(0.9, 1.1); 
            const photoCount = CONFIG.photoCount;
            for (let i = 0; i < photoCount; i++) {
                const imgUrl = defaultImages[i % defaultImages.length];
                const photoContainer = new THREE.Group();
                const borderMat = new THREE.MeshStandardMaterial({ color: 0xccaa00, metalness: 0.9, roughness: 0.3 }); 
                const borderMesh = new THREE.Mesh(borderGeo, borderMat);
                borderMesh.position.z = -0.01; photoContainer.add(borderMesh);
                loader.load(imgUrl, (tex) => {
                    tex.colorSpace = THREE.SRGBColorSpace;
                    const photoMat = new THREE.MeshBasicMaterial({ map: tex, side: THREE.DoubleSide });
                    const photoMesh = new THREE.Mesh(frameGeo, photoMat);
                    photoMesh.userData = { isPhoto: true, parentGroup: photoContainer };
                    photoContainer.add(photoMesh);
                    photoObjects.push(photoMesh);
                });
                const h = Math.random() * 0.8 + 0.1; 
                const angle = (i / photoCount) * Math.PI * 2 + Math.random(); 
                const treeRadiusAtHeight = (1 - h) * 9; 
                const r = treeRadiusAtHeight + 1.5; 
                const x = Math.cos(angle) * r; const y = h * 22 - 11; const z = Math.sin(angle) * r;
                photoContainer.position.set(x, y, z);
                photoContainer.lookAt(0, y, 0); photoContainer.rotateY(Math.PI); photoContainer.rotateZ((Math.random()-0.5) * 0.2); 
                photoContainer.userData = { originalPos: new THREE.Vector3(x, y, z), originalRot: photoContainer.rotation.clone(), phase: Math.random() * Math.PI * 2, isActive: false };
                photoGroup.add(photoContainer);
            }
        }

        function handlePhotoUpload(e) {
            const files = e.target.files; if (!files.length) return;
            let fileIdx = 0; const reader = new FileReader();
            const loadNextFile = () => {
                if (fileIdx >= files.length) return; 
                const file = files[fileIdx];
                reader.onload = (event) => {
                    const img = new Image(); img.src = event.target.result;
                    img.onload = () => {
                        const texture = new THREE.Texture(img); texture.colorSpace = THREE.SRGBColorSpace; texture.needsUpdate = true;
                        const targetMesh = photoObjects[fileIdx % photoObjects.length];
                        if (targetMesh) { targetMesh.material.map = texture; targetMesh.material.needsUpdate = true; }
                        fileIdx++; loadNextFile(); 
                    };
                };
                reader.readAsDataURL(file);
            };
            loadNextFile();
        }

        // --- äº¤äº’ç³»ç»Ÿ (PC/æ‰‹æœºé€šç”¨) ---
        function onTouchStart(event) {
            if (event.touches.length > 0) {
                mouse.x = (event.touches[0].clientX / window.innerWidth) * 2 - 1;
                mouse.y = -(event.touches[0].clientY / window.innerHeight) * 2 + 1;
                checkIntersection(true); 
            }
        }
        function onTouchMove(event) {
            if (event.touches.length > 0) {
                mouse.x = (event.touches[0].clientX / window.innerWidth) * 2 - 1;
                mouse.y = -(event.touches[0].clientY / window.innerHeight) * 2 + 1;
            }
        }
        function onMouseMove(event) {
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
        }

        function checkIntersection(isTap = false) {
            if (!photoGroup.visible) return;
            raycaster = raycaster || new THREE.Raycaster();
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(photoObjects);
            
            if (intersects.length > 0) {
                const hitObj = intersects[0].object;
                if (hoveredObject !== hitObj) { 
                    hoveredObject = hitObj; 
                    hoverStartTime = Date.now(); 
                } 
                // PCä¸Š 300ms, æ‰‹æœºä¸Š 600ms æˆ–ç‚¹å‡»
                const threshold = (isTap) ? 0 : 300;
                if (Date.now() - hoverStartTime > threshold) {
                    if (activePhoto !== hitObj.userData.parentGroup) {
                        if (activePhoto) activePhoto.userData.isActive = false;
                        activePhoto = hitObj.userData.parentGroup; activePhoto.userData.isActive = true;
                    }
                }
            } else {
                hoveredObject = null;
                // ç‚¹å‡»ç©ºç™½å¤„è¿˜åŸ
                if (isTap && activePhoto) { 
                    activePhoto.userData.isActive = false; 
                    activePhoto = null; 
                }
            }
        }

        function createParticles() {
            geometry = new THREE.BufferGeometry();
            const positions = new Float32Array(CONFIG.particleCount * 3);
            const targets = new Float32Array(CONFIG.particleCount * 3);
            for (let i = 0; i < CONFIG.particleCount * 3; i++) { positions[i] = (Math.random() - 0.5) * 50; targets[i] = positions[i]; }
            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            geometry.setAttribute('target', new THREE.BufferAttribute(targets, 3));
            material = new THREE.PointsMaterial({
                size: CONFIG.particleSize, color: new THREE.Color('white'), transparent: true, opacity: 0.5,
                blending: THREE.AdditiveBlending, depthWrite: false
            });
            particles = new THREE.Points(geometry, material); particles.frustumCulled = false; scene.add(particles);
        }

        function updateShape(shapeName) {
            const arr = new Float32Array(CONFIG.particleCount * 3);
            for (let i = 0; i < CONFIG.particleCount; i++) {
                let x, y, z; const idx = i * 3;
                if (shapeName === 'åœ£è¯æ ‘') {
                    const h = Math.random(); const angle = Math.random() * Math.PI * 2; const r = (1 - h) * 8;
                    x = Math.cos(angle) * r; y = h * 22 - 11; z = Math.sin(angle) * r;
                } else {
                    x = (Math.random()-0.5)*50; y = (Math.random()-0.5)*50; z = (Math.random()-0.5)*50;
                }
                arr[idx] = x; arr[idx+1] = y; arr[idx+2] = z;
            }
            geometry.attributes.target.array.set(arr);
            geometry.attributes.target.needsUpdate = true;
            
            if (shapeName === 'åœ£è¯æ ‘') {
                luxuryGroup.visible = true; photoGroup.visible = true;
                treeOrnaments.forEach(o => { o.currentPos.copy(o.basePos); });
            }
        }

        function showTip() {
            const tip = document.getElementById('tips');
            tip.style.opacity = 1;
            setTimeout(() => { tip.style.opacity = 0; }, 5000);
        }

        function onWindowResize() { 
            camera.aspect = window.innerWidth / window.innerHeight; 
            camera.updateProjectionMatrix(); 
            renderer.setSize(window.innerWidth, window.innerHeight); 
            composer.setSize(window.innerWidth, window.innerHeight); 
        }

        function animate() {
            requestAnimationFrame(animate);
            const time = Date.now() * 0.001;
            const dummy = new THREE.Object3D();

            // æŒç»­æ£€æµ‹é¼ æ ‡æ‚¬åœï¼ˆPCç«¯ï¼‰
            if(!hoveredObject && !activePhoto) checkIntersection(false); 

            if (luxuryGroup.visible) {
                if (foliageSystem) foliageSystem.material.uniforms.time.value = time;
                if (starMesh) { starMesh.rotation.y = -time * 0.3; const hue = (time * 0.1) % 1.0; starLight.color.setHSL(hue, 0.7, 0.5); }
                if (spiralMaterial) { const lightness = 0.4 + Math.sin(time * 3.0) * 0.2; spiralMaterial.color.setHSL(0.08, 1.0, lightness); }

                const explosionFactor = CONFIG.mode === 'AR' ? CONFIG.expansion * 2.0 : 0; 
                
                for(let i=0; i<treeOrnaments.length; i++) {
                    const o = treeOrnaments[i];
                    const targetX = o.basePos.x * (1 + explosionFactor); const targetY = o.basePos.y * (1 + explosionFactor); const targetZ = o.basePos.z * (1 + explosionFactor);
                    let floatSpeed = 1.0; let floatAmp = 0.1;
                    if(o.weightType === 2) { floatSpeed = 0.5; floatAmp = 0.02; } if(o.weightType === 1) { floatSpeed = 1.2; floatAmp = 0.05; } if(o.weightType === 0) { floatSpeed = 2.0; floatAmp = 0.08; } 
                    const floatY = Math.sin(time * floatSpeed + o.phase) * floatAmp;
                    o.currentPos.x += (targetX - o.currentPos.x) * 0.05; o.currentPos.y += ((targetY + floatY) - o.currentPos.y) * 0.05; o.currentPos.z += (targetZ - o.currentPos.z) * 0.05;
                    dummy.position.copy(o.currentPos); dummy.scale.setScalar(o.baseScale);
                    if (o.weightType === 2) dummy.rotation.set(0, time * 0.2 + o.phase, 0); else dummy.rotation.set(0, 0, 0); dummy.updateMatrix();
                    if (o.weightType === 2) instancedGifts.setMatrixAt(o.index, dummy.matrix); else if (o.weightType === 1) instancedBalls.setMatrixAt(o.index, dummy.matrix); else if (o.weightType === 0) instancedLights.setMatrixAt(o.index, dummy.matrix); else if (o.mesh === spiralMesh) spiralMesh.setMatrixAt(o.index, dummy.matrix);
                }
                instancedGifts.instanceMatrix.needsUpdate = true; instancedBalls.instanceMatrix.needsUpdate = true; instancedLights.instanceMatrix.needsUpdate = true; if(spiralMesh) spiralMesh.instanceMatrix.needsUpdate = true;
                
                if (photoGroup) {
                    photoGroup.children.forEach(photo => {
                        if (photo.userData.isActive) {
                            const cameraDir = new THREE.Vector3(); camera.getWorldDirection(cameraDir);
                            const targetPos = camera.position.clone().add(cameraDir.multiplyScalar(8)); 
                            photo.position.lerp(targetPos, 0.05); photo.scale.lerp(new THREE.Vector3(5.0, 5.0, 5.0), 0.05); 
                            photo.lookAt(camera.position);
                        } else {
                            const original = photo.userData.originalPos; const t = time + photo.userData.phase;
                            const floatY = Math.sin(t * 0.5) * 0.2;
                            photo.position.lerp(new THREE.Vector3(original.x, original.y + floatY, original.z), 0.05);
                            photo.scale.lerp(new THREE.Vector3(1, 1, 1), 0.05);
                            const dummyObj = new THREE.Object3D(); dummyObj.position.copy(photo.position); dummyObj.lookAt(0, original.y, 0); dummyObj.rotateY(Math.PI); 
                            photo.quaternion.slerp(dummyObj.quaternion, 0.1);
                        }
                    });
                }
            }
            
            controls.update();
            if (controls.autoRotate && !activePhoto && CONFIG.mode === '3D') { luxuryGroup.rotation.y += 0.002; particles.rotation.y += 0.002; }

            composer.render();
        }
    </script>
</body>
</html>